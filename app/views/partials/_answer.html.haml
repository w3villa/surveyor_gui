-# TODO: disabled
- rg ||= nil
- r = response_for(@response_set, q, a, rg)
- i = response_idx(q.pick != "one") # argument will be false (don't increment i) if we're on radio buttons
- disabled = defined?(disableFlag) ? disableFlag : false
= f.semantic_fields_for i, r do |ff|
  = ff.input :question_id, :as => :quiet unless q.pick == "one" # don't repeat question_id if we're on radio buttons
  = ff.input :api_id, :as => :quiet unless q.pick == "one"
  = ff.input :response_group, :input_html => { :value => rg }, :as => :quiet if q.pick != "one" && g && g.display_type == "repeater"
  - case q.pick
  - when "one"
    - if !params[:rm_id].present?
      = ff.input :answer_id, :as => :surveyor_radio, :collection => [[a.text_for(nil, @render_context, I18n.locale), a.id]], :label => false, :input_html => {:class => a.css_class, :disabled => disabled}, :response_class => a.response_class, wrapper_html: { class: answer_result_css_class(ff.object, a, q) }
    - if params[:profile_id].present? && ff.object.question.answers.last.id == a.id
      %label.employee-response-label (By Employee)
      = text_field_tag 'custom_text_input', ResponseSet.where(user_id: params["profile_id"], survey_id: params["survey_id"])&.first&.responses&.where(question_id: ff.object.question_id)&.first&.answer&.text, class: a.css_class, readonly: true
    - if params[:rm_id].present? && ff.object.question.answers.last.id == a.id
      %label.employee-response-label (By Reporting Manager)
      = text_field_tag 'custom_text_input', ResponseSet.where(user_id: params["rm_id"], survey_id: params["survey_id"])&.last&.responses&.where(question_id: ff.object.question_id)&.first&.answer&.text, class: a.css_class, readonly: true
  - when "any"
    - if ff.object.question.answers.first.id == a.id && !params[:rm_id].present?
      %p.check-box (More than one answer can be chosen)
    - if !params[:rm_id].present?
      = ff.input :answer_id, :as => :surveyor_check_boxes, :collection => [[a.text_for(nil, @render_context, I18n.locale), a.id]], :label => false, :input_html => {:class => a.css_class, :disabled => disabled}, :response_class => a.response_class, wrapper_html: { class: answer_result_css_class(ff.object, a, q) }
    - if params[:profile_id].present? && ff.object.question.answers.last.id == a.id
      %label.employee-response-label (By Employee)
      = text_field_tag 'custom_text_input', ResponseSet.where(user_id: params["profile_id"], survey_id: params["survey_id"])&.first&.responses&.where(question_id: ff.object.question_id)&.first&.answer&.text, class: a.css_class, readonly: true
    - if params[:rm_id].present? && ff.object.question.answers.last.id == a.id
      %label.employee-response-label (By Reporting Manager)
      = text_field_tag 'custom_text_input', ResponseSet.where(user_id: params["rm_id"], survey_id: params["survey_id"])&.last&.responses&.where(question_id: ff.object.question_id)&.first&.answer&.text, class: a.css_class, readonly: true
  - when "none"
    - if %w(date datetime time float integer string text stars).include? a.response_class
      - if !params[:rm_id].present?
        = ff.input :answer_id, :as => :quiet, :input_html => {:class => a.css_class, :value => a.id}
        = ff.input rc_to_attr(a.response_class),
                  :as         => rc_to_as(a.response_class),
                  :label      => a.text_for(:pre, @render_context, I18n.locale).blank? ? false : a.text_for(:pre, @render_context, I18n.locale),
                  :hint       => a.text_for(:post, @render_context, I18n.locale),
                  :input_html => generate_pick_none_input_html(r.to_formatted_s, a.default_value_for(@render_context, I18n.locale), a.css_class, a.response_class, disabled, a.input_mask, a.input_mask_placeholder)
      - if params[:profile_id].present? && ff.object.question.answers.last.id == a.id
        %label.employee-response-label (By Employee)
        = text_field_tag 'custom_text_input', ResponseSet.where(user_id: params["profile_id"], survey_id: params["survey_id"])&.first&.responses&.where(question_id: ff.object.question_id)&.first&.string_value, class: a.css_class, readonly: true
      - if params[:rm_id].present? && ff.object.question.answers.last.id == a.id
        %label.employee-response-label (By Reporting Manager)
        = text_field_tag 'custom_text_input', ResponseSet.where(user_id: params["rm_id"], survey_id: params["survey_id"])&.last&.responses&.where(question_id: ff.object.question_id)&.first&.string_value, class: a.css_class, readonly: true
    - elsif a.response_class=='blob'
      = ff.input :answer_id, :as => :quiet, :input_html => {:class => a.css_class, :value => a.id}
      = ff.input :blob, :as => :file, :label => false, :input_html => {"data-object-class"=>ff.object.class.name, "data-object-id"=>ff.object.id, "data-response_set_id" => @response_set.id, :required=>q.mandatory?}
      .filename_with_link{:data=>{'image-path'=>'#{image_path("delete.png")}'}}
        - if !ff.object.blob_identifier.blank?
          current file is:
          = link_to ff.object.blob_identifier, "#{request.protocol}#{request.host_with_port}#{ff.object.blob_url}", :target=>'_blank'
    - else
      = a.text_for(nil, @render_context, I18n.locale)
  %span.help= a.help_text_for(@render_context, I18n.locale) unless g && g.display_type == "grid"
